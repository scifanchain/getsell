# å…¬å¼€åŒæ­¥ + æƒé™æ§åˆ¶æ¶æ„æ–¹æ¡ˆ

## ğŸ¯ éœ€æ±‚æ¾„æ¸…

### æ‚¨çš„å®é™…éœ€æ±‚

```
æ‰€æœ‰ç”¨æˆ·éƒ½èƒ½çœ‹åˆ°æ‰€æœ‰å†…å®¹ âœ…
â”œâ”€â”€ ç”¨æˆ· A åˆ›å»ºä½œå“
â”‚   â”œâ”€â”€ æ‰€æœ‰äººéƒ½èƒ½çœ‹åˆ°è¿™ä¸ªä½œå“ â† å…¬å¼€å¯è§
â”‚   â”œâ”€â”€ åªæœ‰å—é‚€åä½œè€…èƒ½ç¼–è¾‘ â† æƒé™æ§åˆ¶
â”‚   â””â”€â”€ ç¼–è¾‘åçš„å†…å®¹å¹¿æ’­ç»™æ‰€æœ‰äºº â† å…¨å±€åŒæ­¥
â”‚
â”œâ”€â”€ ç”¨æˆ· B åˆ›å»ºä½œå“
â”‚   â”œâ”€â”€ æ‰€æœ‰äººéƒ½èƒ½çœ‹åˆ°
â”‚   â”œâ”€â”€ åªæœ‰ B å’Œå—é‚€è€…èƒ½ç¼–è¾‘
â”‚   â””â”€â”€ ç¼–è¾‘åå¹¿æ’­ç»™æ‰€æœ‰äºº
â”‚
â””â”€â”€ æ‰€æœ‰ç”¨æˆ·éƒ½åŒæ­¥å…¨é‡æ•°æ® â† å…³é”®ï¼
```

### ç±»ä¼¼çš„äº§å“æ¨¡å‹

```
ç±»ä¼¼äºï¼š
âœ… GitHubï¼ˆæ‰€æœ‰ä»“åº“å¯è§ï¼Œä½†åªæœ‰ contributor èƒ½ pushï¼‰
âœ… ç»´åŸºç™¾ç§‘ï¼ˆæ‰€æœ‰äººå¯è§ï¼Œéƒ¨åˆ†äººå¯ç¼–è¾‘ï¼‰
âœ… å…¬å¼€çš„åä½œæ–‡æ¡£ï¼ˆè§‚çœ‹è€… vs ç¼–è¾‘è€…ï¼‰

ä¸æ˜¯ï¼š
âŒ Google Docsï¼ˆç§æœ‰æ–‡æ¡£ï¼Œé‚€è¯·æ‰èƒ½çœ‹ï¼‰
âŒ Notionï¼ˆæƒé™æ§åˆ¶ä¸¥æ ¼ï¼‰
```

---

## ğŸ—ï¸ æ¨èæ¶æ„ï¼šæ··åˆæ¨¡å¼

### æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          æ‰€æœ‰ç”¨æˆ·çš„å®¢æˆ·ç«¯ï¼ˆ100+ ç”¨æˆ·ï¼‰           â”‚
â”‚                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ å…¨å±€åªè¯» Automerge æ–‡æ¡£                   â”‚  â”‚
â”‚  â”‚ â€¢ æ‰€æœ‰ä½œå“ï¼ˆ1000+ï¼‰                       â”‚  â”‚
â”‚  â”‚ â€¢ æ‰€æœ‰ç« èŠ‚ï¼ˆ20000+ï¼‰                      â”‚  â”‚
â”‚  â”‚ â€¢ æ‰€æœ‰ç”¨æˆ·ä¿¡æ¯                            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                 â”‚                               â”‚
â”‚                 â†“                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ UI æƒé™æ§åˆ¶ï¼ˆæœ¬åœ°éªŒè¯ï¼‰                   â”‚  â”‚
â”‚  â”‚ if (canEdit(work)) {                      â”‚  â”‚
â”‚  â”‚   showEditButton()  â† æœ‰æƒé™              â”‚  â”‚
â”‚  â”‚ } else {                                  â”‚  â”‚
â”‚  â”‚   showReadOnlyView() â† æ— æƒé™             â”‚  â”‚
â”‚  â”‚ }                                         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â”‚ ç¼–è¾‘è¯·æ±‚ï¼ˆå¸¦è®¤è¯ï¼‰
                  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ä¸­å¤®æœåŠ¡å™¨ï¼ˆæƒé™éªŒè¯ + æ•°æ®æºï¼‰          â”‚
â”‚                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ ä¸» Automerge æ–‡æ¡£ï¼ˆå•ä¸€æ•°æ®æºï¼‰           â”‚  â”‚
â”‚  â”‚ globalDoc = Automerge.from({              â”‚  â”‚
â”‚  â”‚   works: [...æ‰€æœ‰ä½œå“],                   â”‚  â”‚
â”‚  â”‚   chapters: [...æ‰€æœ‰ç« èŠ‚]                 â”‚  â”‚
â”‚  â”‚ })                                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                 â”‚                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ æƒé™éªŒè¯æµç¨‹ï¼š                            â”‚  â”‚
â”‚  â”‚ 1. éªŒè¯ JWT token                         â”‚  â”‚
â”‚  â”‚ 2. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰ç¼–è¾‘æƒé™                 â”‚  â”‚
â”‚  â”‚ 3. åº”ç”¨å˜æ›´åˆ°ä¸»æ–‡æ¡£                       â”‚  â”‚
â”‚  â”‚ 4. å¹¿æ’­ç»™æ‰€æœ‰å®¢æˆ·ç«¯ â† å…³é”®ï¼              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â†“ å˜æ›´å¹¿æ’­ï¼ˆWebSocketï¼‰
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                 â”‚          â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”        â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â” â”Œâ”€â”€â–¼â”€â”€â”€â”€â”€â”
    â”‚ ç”¨æˆ· A â”‚        â”‚ ç”¨æˆ· B â”‚ â”‚ ç”¨æˆ· C â”‚
    â”‚ (ç¼–è¾‘) â”‚        â”‚ (åªè¯») â”‚ â”‚ (åªè¯») â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“                 â†“          â†“
    è‡ªåŠ¨æ›´æ–° UI       è‡ªåŠ¨æ›´æ–° UI  è‡ªåŠ¨æ›´æ–° UI
    ï¼ˆæ‰€æœ‰äººçœ‹åˆ°åŒæ ·çš„å†…å®¹ï¼‰
```

---

## ğŸ’» å®Œæ•´å®ç°ä»£ç 

### æœåŠ¡å™¨ç«¯

```typescript
// ===== æœåŠ¡å™¨ç«¯ï¼šæƒå¨æ•°æ®æº =====
import * as Automerge from '@automerge/automerge';
import { WebSocketServer, WebSocket } from 'ws';
import jwt from 'jsonwebtoken';

interface GlobalData {
  works: Work[];
  chapters: Chapter[];
  users: User[];
}

class GlobalSyncServer {
  private globalDoc: Automerge.Doc<GlobalData>;
  private connections: Map<string, WebSocket> = new Map();
  private userTokens: Map<string, string> = new Map();
  
  constructor() {
    this.initGlobalDoc();
    this.setupWebSocketServer();
  }
  
  async initGlobalDoc() {
    console.log('Initializing global document...');
    
    // ä»æ•°æ®åº“åŠ è½½æˆ–åˆ›å»ºæ–°æ–‡æ¡£
    const saved = await this.loadFromDatabase();
    if (saved) {
      this.globalDoc = Automerge.load(saved);
      console.log(`Loaded ${this.globalDoc.works.length} works`);
    } else {
      this.globalDoc = Automerge.from<GlobalData>({
        works: [],
        chapters: [],
        users: []
      });
      console.log('Created new global document');
    }
  }
  
  setupWebSocketServer() {
    const wss = new WebSocketServer({ port: 8080 });
    console.log('WebSocket server listening on port 8080');
    
    wss.on('connection', (ws, req) => {
      // 1. è®¤è¯ç”¨æˆ·
      const userId = this.authenticateUser(req);
      if (!userId) {
        ws.close(1008, 'Authentication failed');
        return;
      }
      
      console.log(`User ${userId} connected`);
      this.connections.set(userId, ws);
      
      // 2. å‘é€å®Œæ•´æ–‡æ¡£ç»™æ–°ç”¨æˆ·
      this.sendFullSync(ws);
      
      // 3. ç›‘å¬ç¼–è¾‘è¯·æ±‚
      ws.on('message', async (data) => {
        try {
          const message = JSON.parse(data.toString());
          await this.handleMessage(userId, message);
        } catch (error) {
          console.error('Message handling error:', error);
          this.sendError(ws, error.message);
        }
      });
      
      ws.on('close', () => {
        console.log(`User ${userId} disconnected`);
        this.connections.delete(userId);
      });
    });
  }
  
  authenticateUser(req: any): string | null {
    // ä» URL å‚æ•°è·å– token
    const url = new URL(req.url, 'http://localhost');
    const token = url.searchParams.get('token');
    
    if (!token) return null;
    
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET) as any;
      return decoded.userId;
    } catch (error) {
      return null;
    }
  }
  
  sendFullSync(ws: WebSocket) {
    // å‘é€å®Œæ•´çš„ Automerge æ–‡æ¡£
    const fullState = Automerge.save(this.globalDoc);
    ws.send(JSON.stringify({
      type: 'full-sync',
      state: Array.from(fullState)
    }));
    console.log(`Sent full sync: ${fullState.length} bytes`);
  }
  
  async handleMessage(userId: string, message: any) {
    const { type, workId, data } = message;
    
    console.log(`Received ${type} from ${userId}`);
    
    switch (type) {
      case 'create_work':
        await this.handleCreateWork(userId, data);
        break;
        
      case 'update_work':
        await this.handleUpdateWork(userId, workId, data);
        break;
        
      case 'delete_work':
        await this.handleDeleteWork(userId, workId);
        break;
        
      case 'create_chapter':
        await this.handleCreateChapter(userId, workId, data);
        break;
        
      case 'update_chapter':
        await this.handleUpdateChapter(userId, data.chapterId, data);
        break;
        
      case 'invite_collaborator':
        await this.handleInviteCollaborator(userId, workId, data.collaboratorId);
        break;
        
      default:
        throw new Error(`Unknown message type: ${type}`);
    }
  }
  
  async handleCreateWork(userId: string, data: any) {
    // åˆ›å»ºä½œå“ï¼ˆä»»ä½•ç”¨æˆ·éƒ½å¯ä»¥ï¼‰
    const oldDoc = this.globalDoc;
    
    this.globalDoc = Automerge.change(this.globalDoc, `Create work by ${userId}`, doc => {
      doc.works.push({
        id: this.generateId(),
        title: data.title,
        description: data.description || '',
        authorId: userId,
        editors: [],  // åˆå§‹æ²¡æœ‰åä½œè€…
        createdAt: Date.now(),
        updatedAt: Date.now(),
        createdBy: userId,
        updatedBy: userId
      });
    });
    
    console.log(`Work created: ${data.title}`);
    
    // å¹¿æ’­ç»™æ‰€æœ‰ç”¨æˆ·
    await this.broadcastChanges(oldDoc);
  }
  
  async handleUpdateWork(userId: string, workId: string, data: any) {
    // 1. æƒé™éªŒè¯
    if (!await this.canEdit(userId, workId)) {
      throw new Error('Permission denied: You cannot edit this work');
    }
    
    // 2. åº”ç”¨å˜æ›´
    const oldDoc = this.globalDoc;
    
    this.globalDoc = Automerge.change(this.globalDoc, `Update work by ${userId}`, doc => {
      const work = doc.works.find(w => w.id === workId);
      if (!work) {
        throw new Error('Work not found');
      }
      
      // æ›´æ–°å­—æ®µ
      if (data.title !== undefined) work.title = data.title;
      if (data.description !== undefined) work.description = data.description;
      
      work.updatedAt = Date.now();
      work.updatedBy = userId;
    });
    
    console.log(`Work updated: ${workId} by ${userId}`);
    
    // 3. å®¡è®¡æ—¥å¿—
    await this.logAction(userId, workId, 'update_work', data);
    
    // 4. å¹¿æ’­ç»™æ‰€æœ‰ç”¨æˆ·
    await this.broadcastChanges(oldDoc);
  }
  
  async handleDeleteWork(userId: string, workId: string) {
    // åªæœ‰ä½œè€…å¯ä»¥åˆ é™¤
    const work = this.globalDoc.works.find(w => w.id === workId);
    if (!work) {
      throw new Error('Work not found');
    }
    
    if (work.authorId !== userId) {
      throw new Error('Permission denied: Only author can delete work');
    }
    
    const oldDoc = this.globalDoc;
    
    this.globalDoc = Automerge.change(this.globalDoc, `Delete work by ${userId}`, doc => {
      // è½¯åˆ é™¤æˆ–ç¡¬åˆ é™¤
      const index = doc.works.findIndex(w => w.id === workId);
      doc.works.splice(index, 1);
      
      // åŒæ—¶åˆ é™¤ç›¸å…³ç« èŠ‚
      doc.chapters = doc.chapters.filter(c => c.workId !== workId);
    });
    
    console.log(`Work deleted: ${workId}`);
    
    await this.broadcastChanges(oldDoc);
  }
  
  async handleCreateChapter(userId: string, workId: string, data: any) {
    // æƒé™éªŒè¯
    if (!await this.canEdit(userId, workId)) {
      throw new Error('Permission denied');
    }
    
    const oldDoc = this.globalDoc;
    
    this.globalDoc = Automerge.change(this.globalDoc, `Create chapter by ${userId}`, doc => {
      doc.chapters.push({
        id: this.generateId(),
        workId,
        title: data.title,
        content: data.content || '',
        order: data.order || 0,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        createdBy: userId,
        updatedBy: userId
      });
    });
    
    console.log(`Chapter created in work ${workId}`);
    
    await this.broadcastChanges(oldDoc);
  }
  
  async handleUpdateChapter(userId: string, chapterId: string, data: any) {
    // æŸ¥æ‰¾ç« èŠ‚æ‰€å±çš„ä½œå“
    const chapter = this.globalDoc.chapters.find(c => c.id === chapterId);
    if (!chapter) {
      throw new Error('Chapter not found');
    }
    
    // æƒé™éªŒè¯
    if (!await this.canEdit(userId, chapter.workId)) {
      throw new Error('Permission denied');
    }
    
    const oldDoc = this.globalDoc;
    
    this.globalDoc = Automerge.change(this.globalDoc, `Update chapter by ${userId}`, doc => {
      const ch = doc.chapters.find(c => c.id === chapterId);
      if (!ch) return;
      
      if (data.title !== undefined) ch.title = data.title;
      if (data.content !== undefined) ch.content = data.content;
      if (data.order !== undefined) ch.order = data.order;
      
      ch.updatedAt = Date.now();
      ch.updatedBy = userId;
    });
    
    await this.broadcastChanges(oldDoc);
  }
  
  async handleInviteCollaborator(userId: string, workId: string, collaboratorId: string) {
    // åªæœ‰ä½œè€…å¯ä»¥é‚€è¯·
    const work = this.globalDoc.works.find(w => w.id === workId);
    if (!work) {
      throw new Error('Work not found');
    }
    
    if (work.authorId !== userId) {
      throw new Error('Permission denied: Only author can invite collaborators');
    }
    
    const oldDoc = this.globalDoc;
    
    this.globalDoc = Automerge.change(this.globalDoc, `Invite collaborator by ${userId}`, doc => {
      const w = doc.works.find(w => w.id === workId);
      if (!w) return;
      
      if (!w.editors) w.editors = [];
      if (!w.editors.includes(collaboratorId)) {
        w.editors.push(collaboratorId);
      }
      
      w.updatedAt = Date.now();
    });
    
    console.log(`Collaborator ${collaboratorId} added to work ${workId}`);
    
    await this.broadcastChanges(oldDoc);
  }
  
  async canEdit(userId: string, workId: string): Promise<boolean> {
    const work = this.globalDoc.works.find(w => w.id === workId);
    if (!work) return false;
    
    // ä½œè€…æˆ–åä½œè€…å¯ä»¥ç¼–è¾‘
    return work.authorId === userId || 
           work.editors?.includes(userId);
  }
  
  async broadcastChanges(oldDoc: Automerge.Doc<GlobalData>) {
    // è®¡ç®—å¢é‡å˜æ›´
    const changes = Automerge.getChanges(oldDoc, this.globalDoc);
    
    if (changes.length === 0) return;
    
    // å¹¿æ’­ç»™æ‰€æœ‰è¿æ¥çš„ç”¨æˆ·
    const message = JSON.stringify({
      type: 'sync-changes',
      changes: changes.map(c => Array.from(c))
    });
    
    let broadcastCount = 0;
    for (const [userId, ws] of this.connections) {
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(message);
        broadcastCount++;
      }
    }
    
    console.log(`Broadcasted ${changes.length} changes to ${broadcastCount} users`);
    
    // æŒä¹…åŒ–åˆ°æ•°æ®åº“
    await this.saveToDatabase();
  }
  
  sendError(ws: WebSocket, message: string) {
    ws.send(JSON.stringify({
      type: 'error',
      message
    }));
  }
  
  async loadFromDatabase(): Promise<Uint8Array | null> {
    // ä»æ•°æ®åº“åŠ è½½ Automerge æ–‡æ¡£
    // è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥ä» Prisma åŠ è½½
    try {
      const fs = require('fs');
      const data = fs.readFileSync('data/global-doc.automerge');
      return new Uint8Array(data);
    } catch (error) {
      return null;
    }
  }
  
  async saveToDatabase() {
    // ä¿å­˜åˆ°æ•°æ®åº“
    const state = Automerge.save(this.globalDoc);
    const fs = require('fs');
    fs.writeFileSync('data/global-doc.automerge', state);
    
    // åŒæ—¶ä¿å­˜åˆ° SQLiteï¼ˆç”¨äºæŸ¥è¯¢ï¼‰
    // await this.syncToSQLite();
  }
  
  async logAction(userId: string, workId: string, action: string, details: any) {
    // å®¡è®¡æ—¥å¿—
    console.log(`[AUDIT] ${userId} ${action} on ${workId}`, details);
  }
  
  generateId(): string {
    // ç”Ÿæˆå”¯ä¸€ ID
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }
}

// å¯åŠ¨æœåŠ¡å™¨
const server = new GlobalSyncServer();
```

### å®¢æˆ·ç«¯

```typescript
// ===== å®¢æˆ·ç«¯ï¼šåªè¯»å‰¯æœ¬ + æƒé™æ§åˆ¶ =====
import * as Automerge from '@automerge/automerge';

interface GlobalData {
  works: Work[];
  chapters: Chapter[];
  users: User[];
}

class GlobalSyncClient {
  private globalDoc: Automerge.Doc<GlobalData>;
  private ws: WebSocket | null = null;
  private currentUserId: string;
  private reconnectAttempts = 0;
  
  constructor(userId: string, token: string) {
    this.currentUserId = userId;
    this.connect(token);
  }
  
  connect(token: string) {
    console.log('Connecting to sync server...');
    
    this.ws = new WebSocket(`wss://sync.myapp.com?token=${token}`);
    
    this.ws.onopen = () => {
      console.log('Connected to sync server');
      this.reconnectAttempts = 0;
    };
    
    this.ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      this.handleMessage(message);
    };
    
    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
    
    this.ws.onclose = () => {
      console.log('Disconnected from sync server');
      this.reconnect(token);
    };
  }
  
  reconnect(token: string) {
    // æŒ‡æ•°é€€é¿é‡è¿
    this.reconnectAttempts++;
    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
    
    console.log(`Reconnecting in ${delay}ms...`);
    setTimeout(() => this.connect(token), delay);
  }
  
  handleMessage(message: any) {
    switch (message.type) {
      case 'full-sync':
        this.handleFullSync(message);
        break;
        
      case 'sync-changes':
        this.handleIncrementalSync(message);
        break;
        
      case 'error':
        this.handleError(message);
        break;
    }
  }
  
  handleFullSync(message: any) {
    console.log('Received full sync');
    
    // åŠ è½½å®Œæ•´æ–‡æ¡£
    this.globalDoc = Automerge.load<GlobalData>(
      new Uint8Array(message.state)
    );
    
    console.log(`Loaded ${this.globalDoc.works.length} works, ${this.globalDoc.chapters.length} chapters`);
    
    // æ¸²æŸ“ UI
    this.renderUI();
  }
  
  handleIncrementalSync(message: any) {
    console.log('Received incremental sync');
    
    // åº”ç”¨å¢é‡å˜æ›´
    const changes = message.changes.map((c: number[]) => new Uint8Array(c));
    this.globalDoc = Automerge.applyChanges(this.globalDoc, changes);
    
    // æ›´æ–° UI
    this.renderUI();
  }
  
  handleError(message: any) {
    console.error('Server error:', message.message);
    alert(`é”™è¯¯: ${message.message}`);
  }
  
  // ===== ç”¨æˆ·æ“ä½œ =====
  
  async createWork(title: string, description: string) {
    this.sendMessage({
      type: 'create_work',
      data: { title, description }
    });
  }
  
  async updateWork(workId: string, updates: Partial<Work>) {
    // æœ¬åœ°æƒé™æ£€æŸ¥ï¼ˆå¿«é€Ÿåé¦ˆï¼‰
    if (!this.canEdit(workId)) {
      alert('æ‚¨æ²¡æœ‰ç¼–è¾‘æ­¤ä½œå“çš„æƒé™');
      return;
    }
    
    this.sendMessage({
      type: 'update_work',
      workId,
      data: updates
    });
  }
  
  async deleteWork(workId: string) {
    const work = this.globalDoc.works.find(w => w.id === workId);
    if (!work) return;
    
    if (work.authorId !== this.currentUserId) {
      alert('åªæœ‰ä½œè€…å¯ä»¥åˆ é™¤ä½œå“');
      return;
    }
    
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä½œå“å—ï¼Ÿ')) {
      return;
    }
    
    this.sendMessage({
      type: 'delete_work',
      workId
    });
  }
  
  async createChapter(workId: string, title: string) {
    if (!this.canEdit(workId)) {
      alert('æ‚¨æ²¡æœ‰ç¼–è¾‘æƒé™');
      return;
    }
    
    this.sendMessage({
      type: 'create_chapter',
      workId,
      data: { title, content: '', order: this.getNextChapterOrder(workId) }
    });
  }
  
  async updateChapter(chapterId: string, updates: Partial<Chapter>) {
    const chapter = this.globalDoc.chapters.find(c => c.id === chapterId);
    if (!chapter) return;
    
    if (!this.canEdit(chapter.workId)) {
      alert('æ‚¨æ²¡æœ‰ç¼–è¾‘æƒé™');
      return;
    }
    
    this.sendMessage({
      type: 'update_chapter',
      data: { chapterId, ...updates }
    });
  }
  
  async inviteCollaborator(workId: string, collaboratorId: string) {
    const work = this.globalDoc.works.find(w => w.id === workId);
    if (!work) return;
    
    if (work.authorId !== this.currentUserId) {
      alert('åªæœ‰ä½œè€…å¯ä»¥é‚€è¯·åä½œè€…');
      return;
    }
    
    this.sendMessage({
      type: 'invite_collaborator',
      workId,
      data: { collaboratorId }
    });
  }
  
  sendMessage(message: any) {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      console.error('WebSocket not connected');
      return;
    }
    
    this.ws.send(JSON.stringify(message));
  }
  
  // ===== æƒé™æ£€æŸ¥ =====
  
  canEdit(workId: string): boolean {
    const work = this.globalDoc.works.find(w => w.id === workId);
    if (!work) return false;
    
    return work.authorId === this.currentUserId || 
           work.editors?.includes(this.currentUserId);
  }
  
  isAuthor(workId: string): boolean {
    const work = this.globalDoc.works.find(w => w.id === workId);
    return work?.authorId === this.currentUserId;
  }
  
  // ===== UI æ¸²æŸ“ =====
  
  renderUI() {
    this.renderWorkList();
  }
  
  renderWorkList() {
    const container = document.getElementById('work-list');
    if (!container) return;
    
    container.innerHTML = '';
    
    // æ¸²æŸ“æ‰€æœ‰ä½œå“ï¼ˆå…¬å¼€å¯è§ï¼‰
    for (const work of this.globalDoc.works) {
      const workElement = this.createWorkElement(work);
      container.appendChild(workElement);
    }
  }
  
  createWorkElement(work: Work): HTMLElement {
    const div = document.createElement('div');
    div.className = 'work-item';
    
    const canEdit = this.canEdit(work.id);
    const isAuthor = this.isAuthor(work.id);
    
    div.innerHTML = `
      <h3>${work.title}</h3>
      <p>${work.description}</p>
      <div class="meta">
        <span>ä½œè€…: ${work.authorId}</span>
        <span>æ›´æ–°: ${new Date(work.updatedAt).toLocaleString()}</span>
      </div>
      <div class="actions">
        ${canEdit ? `
          <button class="edit-btn" data-id="${work.id}">ç¼–è¾‘</button>
        ` : `
          <span class="read-only-badge">åªè¯»</span>
        `}
        ${isAuthor ? `
          <button class="delete-btn" data-id="${work.id}">åˆ é™¤</button>
          <button class="invite-btn" data-id="${work.id}">é‚€è¯·åä½œè€…</button>
        ` : ''}
      </div>
    `;
    
    // ç»‘å®šäº‹ä»¶
    if (canEdit) {
      div.querySelector('.edit-btn')?.addEventListener('click', () => {
        this.openWorkEditor(work.id);
      });
    }
    
    if (isAuthor) {
      div.querySelector('.delete-btn')?.addEventListener('click', () => {
        this.deleteWork(work.id);
      });
      
      div.querySelector('.invite-btn')?.addEventListener('click', () => {
        this.showInviteDialog(work.id);
      });
    }
    
    return div;
  }
  
  openWorkEditor(workId: string) {
    // æ‰“å¼€ç¼–è¾‘å™¨
    console.log('Opening editor for', workId);
    // å®é™…å®ç°...
  }
  
  showInviteDialog(workId: string) {
    const collaboratorId = prompt('è¯·è¾“å…¥è¦é‚€è¯·çš„ç”¨æˆ· ID:');
    if (collaboratorId) {
      this.inviteCollaborator(workId, collaboratorId);
    }
  }
  
  getNextChapterOrder(workId: string): number {
    const chapters = this.globalDoc.chapters.filter(c => c.workId === workId);
    return chapters.length > 0 
      ? Math.max(...chapters.map(c => c.order)) + 1 
      : 0;
  }
}

// åˆå§‹åŒ–å®¢æˆ·ç«¯
const token = localStorage.getItem('auth_token');
const userId = localStorage.getItem('user_id');

if (token && userId) {
  const syncClient = new GlobalSyncClient(userId, token);
  
  // æš´éœ²åˆ°å…¨å±€ï¼Œæ–¹ä¾¿è°ƒè¯•
  (window as any).syncClient = syncClient;
}
```

---

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å»¶è¿ŸåŠ è½½ç« èŠ‚å†…å®¹

```typescript
// å…ƒæ•°æ®åŒæ­¥ï¼Œå†…å®¹æŒ‰éœ€åŠ è½½
interface ChapterMetadata {
  id: string;
  title: string;
  workId: string;
  order: number;
  // ä¸åŒ…å« content
}

class OptimizedSync {
  private globalDoc: Automerge.Doc<{
    works: Work[];
    chapters: ChapterMetadata[];  // åªæœ‰å…ƒæ•°æ®
  }>;
  
  private chapterContentCache: Map<string, string> = new Map();
  
  async loadChapterContent(chapterId: string): Promise<string> {
    if (this.chapterContentCache.has(chapterId)) {
      return this.chapterContentCache.get(chapterId)!;
    }
    
    // ä»æœåŠ¡å™¨æŒ‰éœ€åŠ è½½
    const response = await fetch(`/api/chapters/${chapterId}/content`);
    const content = await response.text();
    
    this.chapterContentCache.set(chapterId, content);
    return content;
  }
}
```

### 2. è™šæ‹Ÿæ»šåŠ¨

```typescript
class VirtualScrollList {
  private visibleRange = { start: 0, end: 20 };
  
  renderWorkList() {
    // åªæ¸²æŸ“å¯è§åŒºåŸŸçš„ä½œå“
    const visibleWorks = this.globalDoc.works.slice(
      this.visibleRange.start,
      this.visibleRange.end
    );
    
    for (const work of visibleWorks) {
      this.renderWork(work);
    }
  }
  
  onScroll(scrollTop: number) {
    // æ›´æ–°å¯è§èŒƒå›´
    this.visibleRange.start = Math.floor(scrollTop / 100);
    this.visibleRange.end = this.visibleRange.start + 20;
    
    this.renderWorkList();
  }
}
```

### 3. å¢é‡æ›´æ–° UI

```typescript
class IncrementalUI {
  handleIncrementalSync(changes: Uint8Array[]) {
    const oldDoc = this.globalDoc;
    this.globalDoc = Automerge.applyChanges(this.globalDoc, changes);
    
    // è®¡ç®—å·®å¼‚
    const patches = Automerge.diff(oldDoc, this.globalDoc);
    
    // åªæ›´æ–°å˜åŒ–çš„éƒ¨åˆ†
    for (const patch of patches) {
      if (patch.path[0] === 'works') {
        const workId = patch.path[1];
        this.updateWorkElement(workId);
      }
    }
  }
  
  updateWorkElement(workId: string) {
    const work = this.globalDoc.works.find(w => w.id === workId);
    const element = document.querySelector(`[data-work-id="${workId}"]`);
    
    if (element && work) {
      // åªæ›´æ–°è¿™ä¸€ä¸ªå…ƒç´ 
      element.querySelector('.title').textContent = work.title;
      element.querySelector('.description').textContent = work.description;
    }
  }
}
```

---

## ğŸ”’ å®‰å…¨ä¸éšç§

### 1. ç«¯åˆ°ç«¯åŠ å¯†ï¼ˆå¯é€‰ï¼‰

```typescript
// å¦‚æœéœ€è¦éšç§ä¿æŠ¤
class EncryptedSync {
  async createWork(title: string) {
    // åŠ å¯†æ•æ„Ÿæ•°æ®
    const encrypted = await this.encrypt(title);
    
    this.sendMessage({
      type: 'create_work',
      data: {
        title: encrypted,  // æœåŠ¡å™¨çœ‹ä¸åˆ°æ˜æ–‡
        encryptedFor: this.getCollaborators()
      }
    });
  }
  
  async decrypt(encrypted: string): Promise<string> {
    // ä½¿ç”¨ç”¨æˆ·çš„ç§é’¥è§£å¯†
    // ...
  }
}
```

### 2. å®¡è®¡æ—¥å¿—

```typescript
// æœåŠ¡å™¨ç«¯è®°å½•æ‰€æœ‰æ“ä½œ
interface AuditLog {
  id: string;
  userId: string;
  action: string;
  workId: string;
  timestamp: number;
  details: any;
}

class AuditService {
  async logAction(log: AuditLog) {
    await prisma.auditLog.create({ data: log });
  }
  
  async getWorkHistory(workId: string) {
    return await prisma.auditLog.findMany({
      where: { workId },
      orderBy: { timestamp: 'desc' }
    });
  }
}
```

---

## ğŸ“ æ€»ç»“

### âœ… å®Œå…¨ç¬¦åˆæ‚¨çš„éœ€æ±‚

```typescript
ç‰¹æ€§æ£€æŸ¥è¡¨:
âœ… æ‰€æœ‰ç”¨æˆ·éƒ½èƒ½çœ‹åˆ°æ‰€æœ‰ä½œå“ï¼ˆå…¬å¼€å¯è§ï¼‰
âœ… åªæœ‰æˆæƒç”¨æˆ·èƒ½ç¼–è¾‘ï¼ˆæƒé™æ§åˆ¶ï¼‰
âœ… ç¼–è¾‘å†…å®¹å®æ—¶å¹¿æ’­ç»™æ‰€æœ‰äººï¼ˆå…¨å±€åŒæ­¥ï¼‰
âœ… æœåŠ¡å™¨éªŒè¯æƒé™ï¼ˆå®‰å…¨ï¼‰
âœ… Automerge CRDTï¼ˆè‡ªåŠ¨åˆå¹¶å†²çªï¼‰
âœ… ç¦»çº¿æŸ¥çœ‹ï¼ˆå®¢æˆ·ç«¯æœ‰å®Œæ•´å‰¯æœ¬ï¼‰
âœ… åœ¨çº¿ç¼–è¾‘ï¼ˆé€šè¿‡æœåŠ¡å™¨éªŒè¯ï¼‰

æ•°æ®æµï¼š
ç”¨æˆ· Aï¼ˆæœ‰æƒé™ï¼‰â†’ ç¼–è¾‘ä½œå“
    â†“
å‘é€åˆ°æœåŠ¡å™¨ â†’ éªŒè¯æƒé™
    â†“
åº”ç”¨åˆ°å…¨å±€ Automerge æ–‡æ¡£
    â†“
å¹¿æ’­ç»™æ‰€æœ‰åœ¨çº¿ç”¨æˆ·ï¼ˆBã€Cã€D...ï¼‰
    â†“
æ‰€æœ‰äººçš„ UI è‡ªåŠ¨æ›´æ–° âœ…
```

### å®æ–½æ­¥éª¤

1. **ç¬¬1å‘¨**ï¼šå®ç°æœåŠ¡å™¨ç«¯ï¼ˆæƒé™éªŒè¯ + Automergeï¼‰
2. **ç¬¬2å‘¨**ï¼šå®ç°å®¢æˆ·ç«¯ï¼ˆWebSocket + UIï¼‰
3. **ç¬¬3å‘¨**ï¼šæ€§èƒ½ä¼˜åŒ–ï¼ˆè™šæ‹Ÿæ»šåŠ¨ + å¢é‡æ›´æ–°ï¼‰
4. **ç¬¬4å‘¨**ï¼šæµ‹è¯•å’Œéƒ¨ç½²

éœ€è¦æˆ‘å¼€å§‹å®ç°ç¬¬1å‘¨çš„æœåŠ¡å™¨ç«¯ä»£ç å—ï¼Ÿ
